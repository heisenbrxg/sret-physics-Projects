<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COMPTON EFFECT</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.8em;
            margin: 0;
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            background: linear-gradient(45deg, #00ffff, #ff69b4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .simulation-area {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .canvas-container {
            flex: 2;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0,255,255,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        #canvas {
            width: 100%;
            height: 500px;
            border: 2px solid rgba(0,255,255,0.5);
            border-radius: 15px;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            cursor: crosshair;
            box-shadow: inset 0 0 50px rgba(0,255,255,0.1);
        }
        
        .controls {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e0e0e0;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
            height: 6px;
            border-radius: 5px;
            background: linear-gradient(90deg, #ff6b6b, #ffa726);
            outline: none;
            -webkit-appearance: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        
        .value-display {
            font-size: 0.95em;
            color: #00ffff;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,255,255,0.5);
        }
        
        .results {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 1px solid rgba(0,255,255,0.3);
        }
        
        .results h3 {
            margin-top: 0;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .result-item span:last-child {
            color: #00ffff;
            font-weight: bold;
        }
        
        .formula {
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            color: #90EE90;
            border: 1px solid rgba(144,238,144,0.3);
            font-size: 1.1em;
            text-shadow: 0 0 5px rgba(144,238,144,0.5);
        }
        
        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ffa726);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px 0;
            font-size: 1.1em;
            box-shadow: 0 4px 15px rgba(255,107,107,0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255,107,107,0.4);
            background: linear-gradient(45deg, #ff5252, #ff9800);
        }
        
        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 8px currentColor;
        }
        
        .detector-value {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 2px solid;
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }
        
        @media (max-width: 768px) {
            .simulation-area {
                flex-direction: column;
            }
            .legend {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåä‚öõÔ∏è COMPTON EFFECT</h1>

        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <canvas id="canvas" width="1000" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ffff; color: #00ffff;"></div>
                        <span>X-ray Source & Beam</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4169E1; color: #4169E1;"></div>
                        <span>Target Electron</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff69b4; color: #ff69b4;"></div>
                        <span>Scattered Photon</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #32cd32; color: #32cd32;"></div>
                        <span>Electron Detector</span>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="energy">üîÜ X-ray Energy (keV)</label>
                    <input type="range" id="energy" min="10" max="1000" value="100" step="5">
                    <div class="value-display" id="energyValue">100 keV</div>
                </div>
                
                <div class="control-group">
                    <label for="angle">üìê Scattering Angle Œ∏ (degrees)</label>
                    <input type="range" id="angle" min="0" max="180" value="90" step="1">
                    <div class="value-display" id="angleValue">90¬∞</div>
                </div>
                
                <button onclick="runAnimation()">üöÄ Fire X-ray Pulse</button>
                
                <div class="formula">
                    Œª' - Œª = (h/m‚ÇÄc)(1 - cos Œ∏)
                    <br><small>Compton Formula</small>
                </div>
                
                <div class="results">
                    <h3>üìä Detection Results</h3>
                    <div class="result-item">
                        <span>Wavelength Shift:</span>
                        <span id="wavelengthShift">0.024 √Ö</span>
                    </div>
                    <div class="result-item">
                        <span>Scattered X-ray Energy:</span>
                        <span id="scatteredEnergy">50.0 keV</span>
                    </div>
                    <div class="result-item">
                        <span>Electron Kinetic Energy:</span>
                        <span id="electronEnergy">50.0 keV</span>
                    </div>
                    <div class="result-item">
                        <span>Electron Recoil Angle:</span>
                        <span id="electronAngle">0.0¬∞</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Detector value displays -->
    <div id="photonDetectorValue" class="detector-value" style="color: #ff69b4; border-color: #ff69b4; display: none;">
        Photon: <span id="photonValueText">0 keV</span>
    </div>
    <div id="electronDetectorValue" class="detector-value" style="color: #32cd32; border-color: #32cd32; display: none;">
        Electron: <span id="electronValueText">0 keV</span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Physical constants
        const h = 6.626e-34;
        const c = 3e8;
        const me = 9.109e-31;
        const compton_wavelength = 2.426e-12;
        
        let animating = false;
        let animationFrame = 0;
        
        // Simulation state
        let photonEnergy = 100;
        let scatteringAngle = 90;
        
        // Enhanced particle system
        let photon = { x: 120, y: 250, vx: 3, vy: 0, energy: 100, trail: [] };
        let electron = { x: 500, y: 250, vx: 0, vy: 0, trail: [] };
        let scatteredPhoton = { x: 500, y: 250, vx: 0, vy: 0, energy: 0, trail: [] };
        let recoilElectron = { x: 500, y: 250, vx: 0, vy: 0, trail: [] };
        
        // Equipment positions (made detectors smaller)
        const xraySource = { x: 80, y: 250, width: 60, height: 80 };
        const target = { x: 470, y: 220, width: 60, height: 60 };
        let photonDetector = { x: 700, y: 150, width: 35, height: 50, angle: 0 };
        let electronDetector = { x: 650, y: 350, width: 35, height: 50, angle: 0 };
        
        function updateValues() {
            photonEnergy = parseFloat(document.getElementById('energy').value);
            scatteringAngle = parseFloat(document.getElementById('angle').value);
            
            document.getElementById('energyValue').textContent = `${photonEnergy} keV`;
            document.getElementById('angleValue').textContent = `${scatteringAngle}¬∞`;
            
            calculateScattering();
            updateDetectorPositions();
            if (!animating) {
                drawStatic();
            }
        }
        
        function updateDetectorPositions() {
            const theta = scatteringAngle * Math.PI / 180;
            const results = calculateScattering();
            const phi = results.electronAngleDeg * Math.PI / 180;
            
            // Position photon detector along scattered photon path
            photonDetector.x = 500 + 200 * Math.cos(theta);
            photonDetector.y = 250 - 200 * Math.sin(theta);
            photonDetector.angle = theta;
            
            // Position electron detector along recoil path
            electronDetector.x = 500 + 180 * Math.cos(phi);
            electronDetector.y = 250 - 180 * Math.sin(phi);
            electronDetector.angle = phi;
            
            // Update detector value positions
            updateDetectorValuePositions();
        }
        
        function updateDetectorValuePositions() {
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            
            const photonValueDiv = document.getElementById('photonDetectorValue');
            const electronValueDiv = document.getElementById('electronDetectorValue');
            
            photonValueDiv.style.left = (rect.left + (photonDetector.x * scaleX)) + 'px';
            photonValueDiv.style.top = (rect.top + (photonDetector.y * scaleY)) + 'px';
            
            electronValueDiv.style.left = (rect.left + (electronDetector.x * scaleX)) + 'px';
            electronValueDiv.style.top = (rect.top + (electronDetector.y * scaleY)) + 'px';
        }
        
        function calculateScattering() {
            const theta = scatteringAngle * Math.PI / 180;
            const wavelengthShift = compton_wavelength * (1 - Math.cos(theta)) * 1e10;
            const energyFactor = 1 / (1 + (photonEnergy / 511) * (1 - Math.cos(theta)));
            const scatteredPhotonEnergy = photonEnergy * energyFactor;
            const electronRecoilEnergy = photonEnergy - scatteredPhotonEnergy;
            const electronAngleRad = Math.atan2(
                photonEnergy * Math.sin(theta),
                511 + photonEnergy - scatteredPhotonEnergy
            );
            const electronAngleDeg = electronAngleRad * 180 / Math.PI;
            
            document.getElementById('wavelengthShift').textContent = `${wavelengthShift.toFixed(4)} √Ö`;
            document.getElementById('scatteredEnergy').textContent = `${scatteredPhotonEnergy.toFixed(1)} keV`;
            document.getElementById('electronEnergy').textContent = `${electronRecoilEnergy.toFixed(1)} keV`;
            document.getElementById('electronAngle').textContent = `${electronAngleDeg.toFixed(1)}¬∞`;
            
            // Update detector value displays
            document.getElementById('photonValueText').textContent = `${scatteredPhotonEnergy.toFixed(1)} keV`;
            document.getElementById('electronValueText').textContent = `${electronRecoilEnergy.toFixed(1)} keV`;
            
            return { scatteredPhotonEnergy, electronRecoilEnergy, electronAngleDeg, wavelengthShift };
        }
        
        function drawXraySource() {
            const source = xraySource;
            
            // Draw X-ray tube housing with enhanced metallic look
            const gradient = ctx.createLinearGradient(source.x - source.width/2, source.y - source.height/2, 
                                                   source.x + source.width/2, source.y + source.height/2);
            gradient.addColorStop(0, '#4a5568');
            gradient.addColorStop(0.3, '#2d3748');
            gradient.addColorStop(0.7, '#1a202c');
            gradient.addColorStop(1, '#0f1419');
            ctx.fillStyle = gradient;
            ctx.fillRect(source.x - source.width/2, source.y - source.height/2, source.width, source.height);
            
            // Add metallic highlight
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(source.x - source.width/2 + 2, source.y - source.height/2 + 2, source.width - 4, 8);
            
            // Draw tungsten target with glow
            ctx.fillStyle = '#8c7853';
            ctx.shadowColor = '#ffa500';
            ctx.shadowBlur = 5;
            ctx.fillRect(source.x + source.width/2 - 8, source.y - 5, 15, 10);
            ctx.shadowBlur = 0;
            
            // Draw cooling fins with better detail
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 2;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(source.x - source.width/2 - 8, source.y + i * 8);
                ctx.lineTo(source.x - source.width/2, source.y + i * 8);
                ctx.stroke();
            }
            
            // Draw X-ray emission cone with enhanced effects
            if (animating && animationFrame < 120) {
                const intensity = 0.4 + 0.3 * Math.sin(animationFrame * 0.2);
                const coneGradient = ctx.createLinearGradient(source.x + source.width/2, source.y, 
                                                           source.x + source.width/2 + 100, source.y);
                coneGradient.addColorStop(0, `rgba(0, 255, 255, ${intensity})`);
                coneGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
                ctx.fillStyle = coneGradient;
                ctx.beginPath();
                ctx.moveTo(source.x + source.width/2, source.y);
                ctx.lineTo(source.x + source.width/2 + 100, source.y - 30);
                ctx.lineTo(source.x + source.width/2 + 100, source.y + 30);
                ctx.closePath();
                ctx.fill();
            }
            
            // Enhanced label with background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(source.x - 35, source.y - source.height/2 - 25, 70, 18);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('X-ray Source', source.x, source.y - source.height/2 - 12);
        }
        
        function drawTarget() {
            const tgt = target;
            
            // Draw target holder with enhanced appearance
            const holderGradient = ctx.createLinearGradient(tgt.x - tgt.width/2, tgt.y - tgt.height/2,
                                                          tgt.x + tgt.width/2, tgt.y + tgt.height/2);
            holderGradient.addColorStop(0, '#95a5a6');
            holderGradient.addColorStop(0.5, '#7f8c8d');
            holderGradient.addColorStop(1, '#5d6d7e');
            ctx.fillStyle = holderGradient;
            ctx.fillRect(tgt.x - tgt.width/2, tgt.y - tgt.height/2, tgt.width, tgt.height);
            
            // Draw carbon sample with enhanced texture
            const sampleGradient = ctx.createRadialGradient(tgt.x, tgt.y, 0, tgt.x, tgt.y, 20);
            sampleGradient.addColorStop(0, '#3c3c3c');
            sampleGradient.addColorStop(0.7, '#2c2c2c');
            sampleGradient.addColorStop(1, '#1c1c1c');
            ctx.fillStyle = sampleGradient;
            ctx.fillRect(tgt.x - 20, tgt.y - 20, 40, 40);
            
            // Add crystalline structure pattern
            ctx.strokeStyle = '#505050';
            ctx.lineWidth = 1;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    ctx.beginPath();
                    ctx.rect(tgt.x + i * 12 - 4, tgt.y + j * 12 - 4, 8, 8);
                    ctx.stroke();
                }
            }
            
            // Draw electrons in sample with enhanced glow
            ctx.fillStyle = '#4169E1';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * 2 * Math.PI;
                const radius = 15 + 3 * Math.sin(animationFrame * 0.1 + i);
                const ex = tgt.x + radius * Math.cos(angle);
                const ey = tgt.y + radius * Math.sin(angle);
                
                // Enhanced electron glow
                ctx.shadowColor = '#4169E1';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(ex, ey, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Electron core
                ctx.fillStyle = '#6495ED';
                ctx.beginPath();
                ctx.arc(ex, ey, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = '#4169E1';
            }
            
            // Enhanced label
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(tgt.x - 35, tgt.y - tgt.height/2 - 25, 70, 18);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Carbon Target', tgt.x, tgt.y - tgt.height/2 - 12);
        }
        
        function drawDetector(detector, label, color, isActive = false, detectedValue = null) {
            ctx.save();
            ctx.translate(detector.x, detector.y);
            ctx.rotate(detector.angle);
            
            // Enhanced detector housing with gradient
            const gradient = ctx.createLinearGradient(-detector.width/2, -detector.height/2, 
                                                   detector.width/2, detector.height/2);
            gradient.addColorStop(0, '#4a5568');
            gradient.addColorStop(0.5, '#2d3748');
            gradient.addColorStop(1, '#1a202c');
            ctx.fillStyle = gradient;
            ctx.fillRect(-detector.width/2, -detector.height/2, detector.width, detector.height);
            
            // Add metallic highlight
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(-detector.width/2 + 1, -detector.height/2 + 1, detector.width - 2, 4);
            
            // Draw scintillator crystal with enhanced effects
            const crystalColor = isActive ? color : '#95a5a6';
            const crystalGradient = ctx.createLinearGradient(-detector.width/2 + 3, -detector.height/2 + 3,
                                                           detector.width/2 - 3, detector.height/2 - 3);
            crystalGradient.addColorStop(0, crystalColor);
            crystalGradient.addColorStop(1, isActive ? 'rgba(255,255,255,0.3)' : '#7f8c8d');
            ctx.fillStyle = crystalGradient;
            ctx.fillRect(-detector.width/2 + 3, -detector.height/2 + 3, detector.width - 6, detector.height - 6);
            
            if (isActive) {
                // Enhanced detection flash with pulsing effect
                const pulseIntensity = 0.5 + 0.5 * Math.sin(animationFrame * 0.5);
                ctx.shadowColor = color;
                ctx.shadowBlur = 20 * pulseIntensity;
                ctx.fillStyle = color;
                ctx.fillRect(-detector.width/2 + 3, -detector.height/2 + 3, detector.width - 6, detector.height - 6);
                ctx.shadowBlur = 0;
                
                // Add detection sparkles
                for (let i = 0; i < 5; i++) {
                    const sparkleX = (Math.random() - 0.5) * (detector.width - 6);
                    const sparkleY = (Math.random() - 0.5) * (detector.height - 6);
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 1, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw PMT with enhanced detail
            ctx.fillStyle = '#34495e';
            ctx.fillRect(-detector.width/2 - 12, -8, 12, 16);
            
            // PMT gradient
            const pmtGradient = ctx.createLinearGradient(-detector.width/2 - 12, -8, -detector.width/2, 8);
            pmtGradient.addColorStop(0, '#4a5568');
            pmtGradient.addColorStop(1, '#2d3748');
            ctx.fillStyle = pmtGradient;
            ctx.fillRect(-detector.width/2 - 12, -8, 12, 16);
            
            // Draw signal wires with glow
            ctx.strokeStyle = isActive ? '#e74c3c' : '#c0392b';
            ctx.lineWidth = 2;
            if (isActive) {
                ctx.shadowColor = '#e74c3c';
                ctx.shadowBlur = 8;
            }
            ctx.beginPath();
            ctx.moveTo(-detector.width/2 - 12, -4);
            ctx.lineTo(-detector.width/2 - 20, -4);
            ctx.moveTo(-detector.width/2 - 12, 4);
            ctx.lineTo(-detector.width/2 - 20, 4);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            ctx.restore();
            
            // Enhanced label with background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(detector.x - 30, detector.y - 45, 60, 16);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, detector.x, detector.y - 32);
        }
        
        function drawWavePacket(x, y, length, amplitude, frequency, color, alpha = 1, phase = 0) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 3;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            
            // Draw wave envelope with enhanced smoothness
            ctx.beginPath();
            for (let i = 0; i <= length; i += 0.5) {
                const envelope = Math.exp(-Math.pow((i - length/2) / (length/4), 2));
                const waveY = y + amplitude * envelope * Math.sin(frequency * i + phase);
                if (i === 0) {
                    ctx.moveTo(x + i, waveY);
                } else {
                    ctx.lineTo(x + i, waveY);
                }
            }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawParticle(particle, color, label, size = 15, showTrail = false) {
            // Draw enhanced particle trail
            if (showTrail && particle.trail.length > 1) {
                for (let i = 0; i < particle.trail.length - 1; i++) {
                    const alpha = (i / particle.trail.length) * 0.6;
                    ctx.strokeStyle = `rgba(${color === '#ff69b4' ? '255,105,180' : '50,205,50'}, ${alpha})`;
                    ctx.lineWidth = 4 - (i / particle.trail.length) * 2;
                    ctx.beginPath();
                    ctx.moveTo(particle.trail[i].x, particle.trail[i].y);
                    ctx.lineTo(particle.trail[i + 1].x, particle.trail[i + 1].y);
                    ctx.stroke();
                }
            }
            
            // Draw particle with enhanced glow effect
            const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, size * 2.5);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.4, color);
            gradient.addColorStop(0.8, `${color}40`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, size * 2.5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw solid particle core
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, size, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw particle outline with enhanced contrast
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw inner highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(particle.x - size/3, particle.y - size/3, size/3, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function drawVelocityVector(fromX, fromY, toX, toY, color, label, energy = null) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 1) return;
            
            const unitX = dx / length;
            const unitY = dy / length;
            
            // Draw vector with enhanced gradient
            const gradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.7, `${color}CC`);
            gradient.addColorStop(1, 'rgba(255,255,255,0.9)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw enhanced arrowhead
            const arrowSize = 15;
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - arrowSize * unitX + arrowSize * unitY / 2, toY - arrowSize * unitY - arrowSize * unitX / 2);
            ctx.lineTo(toX - arrowSize * unitX - arrowSize * unitY / 2, toY - arrowSize * unitY + arrowSize * unitX / 2);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        function drawAngleArc(centerX, centerY, radius, startAngle, endAngle, label) {
            // Draw enhanced arc
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw angle measurement lines with glow
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + radius * 1.2, centerY);
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + radius * 1.2 * Math.cos(endAngle), centerY + radius * 1.2 * Math.sin(endAngle));
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Draw enhanced angle label
            const midAngle = (startAngle + endAngle) / 2;
            const labelX = centerX + (radius + 35) * Math.cos(midAngle);
            const labelY = centerY + (radius + 35) * Math.sin(midAngle);
            
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.fillRect(labelX - 18, labelY - 12, 36, 24);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255,215,0,0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(label, labelX, labelY + 5);
            ctx.shadowBlur = 0;
        }
        
        function drawFieldLines() {
            // Draw enhanced electromagnetic field lines around collision
            if (animating && animationFrame >= 105 && animationFrame <= 125) {
                const fieldIntensity = Math.sin((animationFrame - 105) * Math.PI / 20);
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.4 + 0.4 * fieldIntensity})`;
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;
                
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * 2 * Math.PI;
                    const radius = 25 + 20 * fieldIntensity;
                    
                    ctx.beginPath();
                    ctx.arc(500, 250, radius, angle, angle + Math.PI / 12);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }
        }
        
        function drawStatic() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw enhanced background grid
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 8]);
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw equipment
            drawXraySource();
            drawTarget();
            
            // Draw enhanced incident beam path
            const beamGradient = ctx.createLinearGradient(xraySource.x + 30, xraySource.y, target.x - 30, target.y);
            beamGradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
            beamGradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');
            ctx.strokeStyle = beamGradient;
            ctx.lineWidth = 10;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(xraySource.x + 30, xraySource.y);
            ctx.lineTo(target.x - 30, target.y);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw incident photon wave with enhanced effects
            drawWavePacket(xraySource.x + 30, 250, 350, 22, 0.15, '#00ffff', 0.9);
            
            // Draw electron at collision point
            drawParticle(electron, '#4169E1', 'e‚Åª');
            
            // Calculate and draw post-collision trajectories
            const results = calculateScattering();
            const theta = scatteringAngle * Math.PI / 180;
            const phi = results.electronAngleDeg * Math.PI / 180;
            
            // Draw detectors
            drawDetector(photonDetector, 'Photon Detector', '#ff69b4');
            drawDetector(electronDetector, 'Electron Detector', '#32cd32');
            
            // Draw enhanced predicted trajectories
            const photonEndX = 500 + 300 * Math.cos(theta);
            const photonEndY = 250 - 300 * Math.sin(theta);
            const electronEndX = 500 + 200 * Math.cos(phi);
            const electronEndY = 250 - 200 * Math.sin(phi);
            
            // Photon trajectory
            ctx.strokeStyle = 'rgba(255, 105, 180, 0.5)';
            ctx.lineWidth = 4;
            ctx.setLineDash([12, 6]);
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(500, 250);
            ctx.lineTo(photonEndX, photonEndY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Electron trajectory
            ctx.strokeStyle = 'rgba(50, 205, 50, 0.5)';
            ctx.shadowColor = '#32cd32';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(500, 250);
            ctx.lineTo(electronEndX, electronEndY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Draw scattering angle with enhanced visibility
            if (scatteringAngle > 5 && scatteringAngle < 175) {
                drawAngleArc(500, 250, 60, 0, -theta, `Œ∏ = ${scatteringAngle}¬∞`);
            }
            
            // Draw enhanced energy annotation
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(200, 215, 100, 25);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0,255,255,0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(`E‚ÇÄ = ${photonEnergy} keV`, 250, 232);
            ctx.shadowBlur = 0;
            
            // Hide detector values in static mode
            document.getElementById('photonDetectorValue').style.display = 'none';
            document.getElementById('electronDetectorValue').style.display = 'none';
        }
        
        function runAnimation() {
            if (animating) return;
            
            animating = true;
            animationFrame = 0;
            
            // Reset particle positions and clear trails
            photon = { x: 120, y: 250, vx: 3, vy: 0, energy: photonEnergy, trail: [] };
            electron = { x: 500, y: 250, vx: 0, vy: 0, trail: [] };
            
            const results = calculateScattering();
            const theta = scatteringAngle * Math.PI / 180;
            const phi = results.electronAngleDeg * Math.PI / 180;
            
            scatteredPhoton = {
                x: 500, y: 250,
                vx: 2.5 * Math.cos(theta),
                vy: -2.5 * Math.sin(theta),
                energy: results.scatteredPhotonEnergy,
                trail: []
            };
            
            recoilElectron = {
                x: 500, y: 250,
                vx: 2 * Math.cos(phi),
                vy: -2 * Math.sin(phi),
                trail: []
            };
            
            animate();
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            
            // Draw equipment
            drawXraySource();
            drawTarget();
            
            let photonDetected = false;
            let electronDetected = false;
            
            if (animationFrame < 120) {
                // Before collision - photon approaches slower
                photon.x += photon.vx;
                photon.trail.push({ x: photon.x, y: photon.y });
                if (photon.trail.length > 30) photon.trail.shift();
                
                // Draw incident beam with realistic wave packet
                const beamLength = Math.min(350, photon.x - 120);
                if (beamLength > 0) {
                    drawWavePacket(120, 250, beamLength, 18, 0.2, '#00ffff', 0.9, animationFrame * 0.3);
                }
                
                // Draw electron oscillating slightly
                electron.y = 250 + 2 * Math.sin(animationFrame * 0.2);
                drawParticle(electron, '#4169E1', 'e‚Åª');
                
                // Collision effects when photon reaches target
                if (photon.x >= 480 && photon.x <= 520) {
                    drawFieldLines();
                    
                    // Intense collision flash
                    const collisionProgress = (photon.x - 480) / 40;
                    const flashIntensity = Math.sin(collisionProgress * Math.PI);
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.8})`;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 40;
                    ctx.beginPath();
                    ctx.arc(500, 250, 50 * flashIntensity, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Enhanced energy burst particles
                    for (let i = 0; i < 8; i++) {
                        const burstAngle = (i / 8) * 2 * Math.PI;
                        const burstRadius = 30 * flashIntensity;
                        const bx = 500 + burstRadius * Math.cos(burstAngle);
                        const by = 250 + burstRadius * Math.sin(burstAngle);
                        
                        ctx.fillStyle = `rgba(255, 215, 0, ${flashIntensity * 0.8})`;
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(bx, by, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
                
            } else {
                // After collision - particles scatter
                scatteredPhoton.x += scatteredPhoton.vx;
                scatteredPhoton.y += scatteredPhoton.vy;
                scatteredPhoton.trail.push({ x: scatteredPhoton.x, y: scatteredPhoton.y });
                if (scatteredPhoton.trail.length > 25) scatteredPhoton.trail.shift();
                
                recoilElectron.x += recoilElectron.vx;
                recoilElectron.y += recoilElectron.vy;
                recoilElectron.trail.push({ x: recoilElectron.x, y: recoilElectron.y });
                if (recoilElectron.trail.length > 20) recoilElectron.trail.shift();
                
                // Draw collision point residual glow
                const glowAlpha = Math.max(0, 0.4 - (animationFrame - 120) * 0.008);
                ctx.fillStyle = `rgba(255, 255, 255, ${glowAlpha})`;
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(500, 250, 30, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw scattered photon with wave packet
                if (scatteredPhoton.trail.length > 5) {
                    const waveLength = Math.min(80, scatteredPhoton.trail.length * 3);
                    const startX = scatteredPhoton.x - waveLength;
                    drawWavePacket(startX, scatteredPhoton.y, waveLength, 12, 0.25, '#ff69b4', 0.8, animationFrame * 0.3);
                }
                drawParticle(scatteredPhoton, '#ff69b4', 'Œ≥\'', 10, true);
                
                // Draw recoiling electron
                drawParticle(recoilElectron, '#32cd32', 'e‚Åª\'', 12, true);
                
                // Check for detection
                const photonDist = Math.sqrt(Math.pow(scatteredPhoton.x - photonDetector.x, 2) + 
                                           Math.pow(scatteredPhoton.y - photonDetector.y, 2));
                const electronDist = Math.sqrt(Math.pow(recoilElectron.x - electronDetector.x, 2) + 
                                             Math.pow(recoilElectron.y - electronDetector.y, 2));
                
                photonDetected = photonDist < 25;
                electronDetected = electronDist < 25;
                
                // Show detector values when particles are detected
                if (photonDetected) {
                    document.getElementById('photonDetectorValue').style.display = 'block';
                }
                if (electronDetected) {
                    document.getElementById('electronDetectorValue').style.display = 'block';
                }
                
                // Draw momentum conservation vectors
                if (animationFrame > 135) {
                    const results = calculateScattering();
                    drawVelocityVector(500, 250, scatteredPhoton.x, scatteredPhoton.y, '#ff1493', 'p_Œ≥\'', results.scatteredPhotonEnergy);
                    drawVelocityVector(500, 250, recoilElectron.x, recoilElectron.y, '#00ff00', 'p_e\'', results.electronRecoilEnergy);
                }
            }
            
            // Draw detectors with activity indicators
            drawDetector(photonDetector, 'Photon Detector', '#ff69b4', photonDetected);
            drawDetector(electronDetector, 'Electron Detector', '#32cd32', electronDetected);
            
            // Draw enhanced detection signals
            if (photonDetected) {
                ctx.fillStyle = '#ff69b4';
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff69b4';
                ctx.shadowBlur = 8;
                ctx.fillText('‚úì DETECTED!', photonDetector.x, photonDetector.y + 50);
                ctx.shadowBlur = 0;
            }
            if (electronDetected) {
                ctx.fillStyle = '#32cd32';
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#32cd32';
                ctx.shadowBlur = 8;
                ctx.fillText('‚úì DETECTED!', electronDetector.x, electronDetector.y + 50);
                ctx.shadowBlur = 0;
            }
            
            // Add quantum uncertainty visualization
            if (animating && animationFrame > 90) {
                drawQuantumUncertainty();
            }
            
            animationFrame++;
            
            if (animationFrame < 280 && 
                scatteredPhoton.x < canvas.width - 30 && 
                recoilElectron.x < canvas.width - 30 &&
                scatteredPhoton.y > 30 && scatteredPhoton.y < canvas.height - 30 &&
                recoilElectron.y > 30 && recoilElectron.y < canvas.height - 30) {
                requestAnimationFrame(animate);
            } else {
                animating = false;
                setTimeout(() => {
                    drawStatic();
                    // Hide detector values when animation ends
                    document.getElementById('photonDetectorValue').style.display = 'none';
                    document.getElementById('electronDetectorValue').style.display = 'none';
                }, 500);
            }
        }
        
        function drawQuantumUncertainty() {
            // Draw enhanced probability clouds around particles
            const uncertainty = 10;
            
            // Scattered photon uncertainty
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * 2 * Math.PI;
                const radius = uncertainty * Math.random();
                const px = scatteredPhoton.x + radius * Math.cos(angle);
                const py = scatteredPhoton.y + radius * Math.sin(angle);
                
                ctx.fillStyle = `rgba(255, 105, 180, ${0.15 * Math.random()})`;
                ctx.beginPath();
                ctx.arc(px, py, 2 + Math.random(), 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Electron uncertainty
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * 2 * Math.PI;
                const radius = uncertainty * Math.random();
                const ex = recoilElectron.x + radius * Math.cos(angle);
                const ey = recoilElectron.y + radius * Math.sin(angle);
                
                ctx.fillStyle = `rgba(50, 205, 50, ${0.2 * Math.random()})`;
                ctx.beginPath();
                ctx.arc(ex, ey, 2 + Math.random(), 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function addPhotonEmission() {
            // Add enhanced photon emission effects from X-ray source
            if (Math.random() < 0.4 && !animating) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 5;
                const emitX = xraySource.x + 25 + Math.random() * 10;
                const emitY = xraySource.y + (Math.random() - 0.5) * 10;
                ctx.beginPath();
                ctx.arc(emitX, emitY, 2 + Math.random(), 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        function resetSimulation() {
            animating = false;
            photon = { x: 120, y: 250, vx: 3, vy: 0, energy: photonEnergy, trail: [] };
            electron = { x: 500, y: 250, vx: 0, vy: 0, trail: [] };
            scatteredPhoton = { x: 500, y: 250, vx: 0, vy: 0, energy: 0, trail: [] };
            recoilElectron = { x: 500, y: 250, vx: 0, vy: 0, trail: [] };
            updateDetectorPositions();
            drawStatic();
        }
        
        // Event listeners
        document.getElementById('energy').addEventListener('input', updateValues);
        document.getElementById('angle').addEventListener('input', updateValues);
        
        // Enhanced interactive canvas
        canvas.addEventListener('click', function(event) {
            if (animating) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (canvas.height / rect.height);
            
            // Calculate angle from collision point to click point
            const dx = x - 500;
            const dy = 250 - y;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            if (angle < 0) angle += 360;
            if (angle > 180) angle = 360 - angle;
            angle = Math.max(0, Math.min(180, angle));
            
            document.getElementById('angle').value = angle;
            updateValues();
        });
        
        // Add mouse hover effects
        canvas.addEventListener('mousemove', function(event) {
            if (animating) return;
            canvas.style.cursor = 'crosshair';
        });
        
        // Window resize handler to update detector positions
        window.addEventListener('resize', updateDetectorValuePositions);
        
        // Initialize simulation
        updateValues();
        drawStatic();
        
        // Add ambient effects with enhanced timing
        setInterval(() => {
            if (!animating) {
                addPhotonEmission();
            }
        }, 150);
        
        // Performance monitoring
        let lastFrameTime = performance.now();
        function updatePerformanceStats() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            const fps = Math.round(1000 / deltaTime);
            lastFrameTime = currentTime;
            
            if (animating) {
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`${fps} FPS`, canvas.width - 10, 20);
            }
        }
        
        // Enhanced animation loop with performance monitoring
        const originalAnimate = animate;
        animate = function() {
            originalAnimate();
            updatePerformanceStats();
            updateDetectorValuePositions();
            
            // Add dynamic lighting effects during collision
            if (animating && animationFrame >= 115 && animationFrame <= 125) {
                const intensity = Math.sin((animationFrame - 115) * Math.PI / 10);
                canvas.style.filter = `brightness(${1 + intensity * 0.4}) saturate(${1 + intensity * 0.6})`;
            } else {
                canvas.style.filter = 'brightness(1) saturate(1)';
            }
        };
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    runAnimation();
                    break;
                case 'r':
                case 'R':
                    resetSimulation();
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    document.getElementById('energy').value = Math.min(1000, parseInt(document.getElementById('energy').value) + 10);
                    updateValues();
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    document.getElementById('energy').value = Math.max(10, parseInt(document.getElementById('energy').value) - 10);
                    updateValues();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    document.getElementById('angle').value = Math.max(0, parseInt(document.getElementById('angle').value) - 5);
                    updateValues();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    document.getElementById('angle').value = Math.min(180, parseInt(document.getElementById('angle').value) + 5);
                    updateValues();
                    break;
            }
        });
        
        // Show enhanced keyboard shortcuts info
        setTimeout(() => {
            if (!animating) {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'left';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 2;
                ctx.fillText('üí° Tips: Click to set angle ‚Ä¢ Space: Run ‚Ä¢ R: Reset ‚Ä¢ Arrows: Adjust values', 10, canvas.height - 10);
                ctx.shadowBlur = 0;
            }
        }, 2000);
    </script>
</body>
</html>