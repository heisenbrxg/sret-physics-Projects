<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Doppler Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .simulation-area {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .graph-container {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .controls {
            width: 320px;
            background: rgba(30, 30, 50, 0.9);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        canvas {
            width: 100%;
            background: #000;
            border-radius: 10px;
            display: block;
        }

        #simCanvas {
            height: 400px;
        }

        #graphCanvas {
            height: 250px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #64b5f6;
        }

        .control-group input[type="number"] {
            width: 100%;
            padding: 10px;
            background: rgba(100, 181, 246, 0.1);
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 1em;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .control-group input[type="number"]:focus {
            border-color: #64b5f6;
        }

        .control-group input[type="number"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .velocity-section {
            background: rgba(100, 181, 246, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .velocity-section.blueshift {
            border-left: 4px solid #4dabf7;
        }

        .velocity-section.redshift {
            border-left: 4px solid #ff6b6b;
        }

        .velocity-section h3 {
            font-size: 0.95em;
            margin-bottom: 10px;
            color: #90caf9;
        }

        .velocity-section.blueshift h3 {
            color: #4dabf7;
        }

        .velocity-section.redshift h3 {
            color: #ff6b6b;
        }

        .velocity-hint {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 5px;
        }

        .status {
            padding: 15px;
            background: rgba(100, 181, 246, 0.1);
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #64b5f6;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .status-label {
            color: #90caf9;
        }

        .status-value {
            font-weight: bold;
        }

        .redshift {
            color: #ff6b6b;
        }

        .blueshift {
            color: #4dabf7;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .shift-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 0 0 10px currentColor;
            transition: all 0.3s ease;
        }

        .observer-section {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Quantum Doppler Effect Simulation</h1>

        <div class="main-content">
            <div class="left-section">
                <div class="simulation-area">
                    <div class="shift-indicator" id="shiftIndicator"></div>
                    <canvas id="simCanvas"></canvas>
                </div>

                <div class="graph-container">
                    <canvas id="graphCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #64b5f6;"></div>
                            <span>Rest Wavelength</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" id="observedColor"></div>
                            <span>Observed Wavelength</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <div class="status">
                    <div class="status-item">
                        <span class="status-label">Effect:</span>
                        <span class="status-value" id="effectType">Neutral</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Velocity:</span>
                        <span class="status-value" id="velocityDisplay">0 m/s</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Observed Î»:</span>
                        <span class="status-value" id="observedWavelength">550 nm</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Observed f:</span>
                        <span class="status-value" id="observedFrequency">545 THz</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Shift:</span>
                        <span class="status-value" id="shift">0%</span>
                    </div>
                </div>

                <div class="velocity-section blueshift">
                    <h3>ðŸ”µ Velocity (Star Moving Towards Earth)</h3>
                    <label style="font-size: 0.85em; color: #90caf9; margin-bottom: 5px; display: block;">Enter velocity
                        in m/s</label>
                    <input type="number" id="blueshiftVelocity" placeholder="e.g., 50000000" step="1000000">
                    <div class="velocity-hint">Positive values (star approaching)</div>
                </div>

                <div class="velocity-section redshift">
                    <h3>ðŸ”´ Velocity (Star Moving Away from Earth)</h3>
                    <label style="font-size: 0.85em; color: #90caf9; margin-bottom: 5px; display: block;">Enter velocity
                        in m/s</label>
                    <input type="number" id="redshiftVelocity" placeholder="e.g., 50000000" step="1000000">
                    <div class="velocity-hint">Positive values (star receding)</div>
                </div>

                <div class="observer-section">
                    <canvas id="observerCanvas" width="250" height="250"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const simCanvas = document.getElementById('simCanvas');
        const graphCanvas = document.getElementById('graphCanvas');
        const observerCanvas = document.getElementById('observerCanvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCtx = graphCanvas.getContext('2d');
        const obsCtx = observerCanvas.getContext('2d');

        const c = 299792458;
        let velocityMeters = 0;
        let restWavelength = 550;
        let restFrequency = 545;
        let animSpeed = 0.3;
        let time = 0;
        let starPosition = 0.2;
        let targetStarPosition = 0.2;

        function resizeCanvas() {
            simCanvas.width = simCanvas.offsetWidth;
            simCanvas.height = simCanvas.offsetHeight;
            graphCanvas.width = graphCanvas.offsetWidth;
            graphCanvas.height = graphCanvas.offsetHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function drawObserver() {
            const w = observerCanvas.width;
            const h = observerCanvas.height;

            // Clear canvas with dark blue background
            obsCtx.fillStyle = '#1a1a3e';
            obsCtx.fillRect(0, 0, w, h);

            // Draw stars in background
            obsCtx.fillStyle = '#ffffff';
            const starPositions = [
                { x: 70, y: 30, size: 2 },
                { x: 150, y: 20, size: 1.5 },
                { x: 200, y: 40, size: 2.5 },
                { x: 50, y: 80, size: 1.2 },
                { x: 220, y: 70, size: 1.8 },
                { x: 100, y: 50, size: 1 },
                { x: 180, y: 90, size: 1.5 }
            ];

            starPositions.forEach(star => {
                // Draw star with glow
                obsCtx.beginPath();
                obsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                obsCtx.fill();

                // Add cross sparkle
                obsCtx.lineWidth = 0.5;
                obsCtx.beginPath();
                obsCtx.moveTo(star.x - star.size * 2, star.y);
                obsCtx.lineTo(star.x + star.size * 2, star.y);
                obsCtx.moveTo(star.x, star.y - star.size * 2);
                obsCtx.lineTo(star.x, star.y + star.size * 2);
                obsCtx.stroke();
            });

            // Person positioned on the right side
            const personX = w * 0.75;
            const baseY = h * 0.85;

            // Chair legs
            obsCtx.fillStyle = '#8B4513';
            obsCtx.fillRect(personX - 25, baseY - 10, 4, 15);
            obsCtx.fillRect(personX + 21, baseY - 10, 4, 15);

            // Chair seat
            obsCtx.fillStyle = '#CD5C5C';
            obsCtx.fillRect(personX - 30, baseY - 15, 60, 8);

            // Chair back
            obsCtx.fillStyle = '#CD5C5C';
            obsCtx.fillRect(personX + 22, baseY - 50, 8, 35);

            // Person's legs
            obsCtx.fillStyle = '#FF6B9D';
            obsCtx.fillRect(personX - 12, baseY - 40, 8, 30);
            obsCtx.fillRect(personX + 4, baseY - 40, 8, 30);

            // Person's body (blue shirt)
            obsCtx.fillStyle = '#4A90E2';
            obsCtx.fillRect(personX - 18, baseY - 70, 36, 32);

            // Person's left arm (reaching toward telescope)
            obsCtx.fillStyle = '#4A90E2';
            obsCtx.beginPath();
            obsCtx.moveTo(personX - 18, baseY - 65);
            obsCtx.lineTo(personX - 45, baseY - 80);
            obsCtx.lineWidth = 10;
            obsCtx.strokeStyle = '#4A90E2';
            obsCtx.stroke();

            // Person's right arm
            obsCtx.beginPath();
            obsCtx.moveTo(personX + 18, baseY - 60);
            obsCtx.lineTo(personX + 30, baseY - 50);
            obsCtx.stroke();

            // Person's head (light skin tone) - facing left
            obsCtx.fillStyle = '#E8B89A';
            obsCtx.beginPath();
            obsCtx.arc(personX, baseY - 80, 12, 0, Math.PI * 2);
            obsCtx.fill();

            // Hair (dark blue) - on left side of head
            obsCtx.fillStyle = '#2C3E50';
            obsCtx.beginPath();
            obsCtx.arc(personX + 1, baseY - 86, 13, Math.PI, Math.PI * 2);
            obsCtx.fill();

            // Eye looking toward telescope (left side)
            obsCtx.fillStyle = '#2C3E50';
            obsCtx.beginPath();
            obsCtx.arc(personX - 4, baseY - 80, 2, 0, Math.PI * 2);
            obsCtx.fill();

            // Telescope on tripod - positioned on the LEFT side
            const telX = personX - 60;
            const telY = baseY - 85;

            // Tripod legs
            obsCtx.strokeStyle = '#2C3E50';
            obsCtx.lineWidth = 3;
            obsCtx.beginPath();
            obsCtx.moveTo(telX, telY);
            obsCtx.lineTo(telX - 15, baseY - 10);
            obsCtx.moveTo(telX, telY);
            obsCtx.lineTo(telX + 15, baseY - 10);
            obsCtx.moveTo(telX, telY);
            obsCtx.lineTo(telX, baseY - 10);
            obsCtx.stroke();

            // Telescope body - rotated to point LEFT (toward simulation)
            obsCtx.save();
            obsCtx.translate(telX, telY);
            obsCtx.rotate(Math.PI + Math.PI / 8); // Rotated 180 degrees + slight angle to point left

            // Main tube (cream/beige color)
            obsCtx.fillStyle = '#F5E6D3';
            obsCtx.fillRect(-8, -4, 50, 8);

            // Red stripes on telescope
            obsCtx.fillStyle = '#E74C3C';
            obsCtx.fillRect(5, -4, 5, 8);
            obsCtx.fillRect(20, -4, 5, 8);

            // Front lens (larger end - now pointing left)
            obsCtx.fillStyle = '#34495E';
            obsCtx.fillRect(-10, -6, 5, 12);

            // Eyepiece (back end - now on right, near person)
            obsCtx.fillStyle = '#2C3E50';
            obsCtx.fillRect(42, -3, 4, 6);

            // Lens reflection/glass
            obsCtx.fillStyle = '#87CEEB';
            obsCtx.globalAlpha = 0.6;
            obsCtx.fillRect(-9, -4, 3, 8);
            obsCtx.globalAlpha = 1;

            obsCtx.restore();

            // Observation lines from telescope pointing LEFT toward simulation
            obsCtx.strokeStyle = 'rgba(100, 181, 246, 0.4)';
            obsCtx.lineWidth = 2;
            obsCtx.setLineDash([3, 3]);
            obsCtx.beginPath();
            obsCtx.moveTo(telX + 15, telY - 6);
            obsCtx.lineTo(5, 30);
            obsCtx.moveTo(telX + 15, telY);
            obsCtx.lineTo(5, 60);
            obsCtx.moveTo(telX + 15, telY + 6);
            obsCtx.lineTo(5, 90);
            obsCtx.stroke();
            obsCtx.setLineDash([]);

            // Add arrow pointing to simulation area
            obsCtx.fillStyle = '#64b5f6';
            obsCtx.beginPath();
            obsCtx.moveTo(10, 60);
            obsCtx.lineTo(20, 55);
            obsCtx.lineTo(20, 65);
            obsCtx.closePath();
            obsCtx.fill();

            // Label
            obsCtx.fillStyle = '#90caf9';
            obsCtx.font = 'bold 14px Arial';
            obsCtx.textAlign = 'center';
            obsCtx.fillText('Observer', w / 2, h - 10);
        }

        function wavelengthToRGB(wavelength) {
            let r, g, b;

            if (wavelength >= 380 && wavelength < 440) {
                r = -(wavelength - 440) / (440 - 380);
                g = 0;
                b = 1;
            } else if (wavelength >= 440 && wavelength < 490) {
                r = 0;
                g = (wavelength - 440) / (490 - 440);
                b = 1;
            } else if (wavelength >= 490 && wavelength < 510) {
                r = 0;
                g = 1;
                b = -(wavelength - 510) / (510 - 490);
            } else if (wavelength >= 510 && wavelength < 580) {
                r = (wavelength - 510) / (580 - 510);
                g = 1;
                b = 0;
            } else if (wavelength >= 580 && wavelength < 645) {
                r = 1;
                g = -(wavelength - 645) / (645 - 580);
                b = 0;
            } else if (wavelength >= 645 && wavelength <= 780) {
                r = 1;
                g = 0;
                b = 0;
            } else if (wavelength < 380) {
                r = 0.5;
                g = 0;
                b = 1;
            } else {
                r = 1;
                g = 0;
                b = 0;
            }

            const factor = wavelength >= 380 && wavelength <= 780 ? 1 : 0.7;
            return `rgb(${Math.floor(r * 255 * factor)}, ${Math.floor(g * 255 * factor)}, ${Math.floor(b * 255 * factor)})`;
        }

        function calculateDopplerShift() {
            const beta = velocityMeters / c;

            if (beta === 0) {
                return {
                    wavelength: restWavelength,
                    frequency: restFrequency
                };
            }

            const observedWavelength = restWavelength * Math.sqrt((1 + beta) / (1 - beta));
            const observedFrequency = restFrequency * Math.sqrt((1 - beta) / (1 + beta));

            return {
                wavelength: observedWavelength,
                frequency: observedFrequency
            };
        }

        function updateStarPosition() {
            const beta = velocityMeters / c;

            if (beta > 0) {
                targetStarPosition = 0.2 - (beta * 0.15);
            } else if (beta < 0) {
                targetStarPosition = 0.2 - (beta * 0.35);
            } else {
                targetStarPosition = 0.2;
            }

            starPosition += (targetStarPosition - starPosition) * 0.05;

            if (starPosition < 0.05) starPosition = 0.05;
            if (starPosition > 0.5) starPosition = 0.5;
        }

        function drawSimulation() {
            const w = simCanvas.width;
            const h = simCanvas.height;

            simCtx.fillStyle = '#000';
            simCtx.fillRect(0, 0, w, h);

            for (let i = 0; i < 100; i++) {
                const x = (i * 137.5) % w;
                const y = (i * 197.3) % h;
                const size = Math.random() * 2;
                simCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`;
                simCtx.fillRect(x, y, size, size);
            }

            updateStarPosition();

            const earthX = w * 0.8;
            const earthY = h / 2;
            const earthRadius = 30;

            const earthGrad = simCtx.createRadialGradient(earthX, earthY, 0, earthX, earthY, earthRadius);
            earthGrad.addColorStop(0, '#4dabf7');
            earthGrad.addColorStop(0.7, '#1971c2');
            earthGrad.addColorStop(1, '#0c4a6e');

            simCtx.fillStyle = earthGrad;
            simCtx.beginPath();
            simCtx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
            simCtx.fill();

            simCtx.fillStyle = '#fff';
            simCtx.font = 'bold 14px Arial';
            simCtx.textAlign = 'center';
            simCtx.fillText('Earth', earthX, earthY + earthRadius + 20);

            const starX = w * starPosition;
            const starY = h / 2;
            const starRadius = 25;

            const starColor = wavelengthToRGB(restWavelength);
            const starGrad = simCtx.createRadialGradient(starX, starY, 0, starX, starY, starRadius * 2);
            starGrad.addColorStop(0, '#fff');
            starGrad.addColorStop(0.3, starColor);
            starGrad.addColorStop(1, 'transparent');

            simCtx.fillStyle = starGrad;
            simCtx.beginPath();
            simCtx.arc(starX, starY, starRadius * 2, 0, Math.PI * 2);
            simCtx.fill();

            simCtx.fillStyle = '#fff';
            simCtx.fillText('Star', starX, starY + starRadius * 2 + 20);

            const doppler = calculateDopplerShift();
            const observedColor = wavelengthToRGB(doppler.wavelength);

            const numWaves = 10;
            const baseWavelength = 35;
            const beta = velocityMeters / c;

            for (let i = 0; i < numWaves; i++) {
                const progress = (time * animSpeed * 2 + i * 0.25) % 1;
                const x = starX + (earthX - starX) * progress;

                let wavelengthScale = 1;
                if (beta > 0) {
                    wavelengthScale = 1 + (beta * 1.5);
                } else if (beta < 0) {
                    wavelengthScale = 1 + (beta * 1.5);
                }

                const currentWavelength = baseWavelength * wavelengthScale;
                const amplitude = 35 - (progress * 12);

                const colorProgress = Math.min(progress * 1.5, 1);
                const r1 = parseInt(starColor.match(/\d+/g)[0]);
                const g1 = parseInt(starColor.match(/\d+/g)[1]);
                const b1 = parseInt(starColor.match(/\d+/g)[2]);
                const r2 = parseInt(observedColor.match(/\d+/g)[0]);
                const g2 = parseInt(observedColor.match(/\d+/g)[1]);
                const b2 = parseInt(observedColor.match(/\d+/g)[2]);

                const r = Math.floor(r1 + (r2 - r1) * colorProgress);
                const g = Math.floor(g1 + (g2 - g1) * colorProgress);
                const b = Math.floor(b1 + (b2 - b1) * colorProgress);

                simCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.9 - progress * 0.4})`;
                simCtx.lineWidth = 3;
                simCtx.beginPath();

                for (let px = 0; px < currentWavelength * 3; px++) {
                    const waveX = x + px - currentWavelength * 1.5;
                    if (waveX > starX && waveX < earthX) {
                        const waveY = starY + Math.sin((px / currentWavelength) * Math.PI * 2) * amplitude;
                        if (px === 0) {
                            simCtx.moveTo(waveX, waveY);
                        } else {
                            simCtx.lineTo(waveX, waveY);
                        }
                    }
                }
                simCtx.stroke();
            }

            if (Math.abs(velocityMeters) > 0.02 * c) {
                const arrowY = starY - starRadius * 2 - 40;
                const arrowLength = Math.min(Math.abs(beta) * 200, 120);

                simCtx.strokeStyle = beta > 0 ? '#ff6b6b' : '#4dabf7';
                simCtx.fillStyle = beta > 0 ? '#ff6b6b' : '#4dabf7';
                simCtx.lineWidth = 3;

                if (beta > 0) {
                    const arrowStartX = starX;
                    const arrowEndX = starX - arrowLength;

                    simCtx.beginPath();
                    simCtx.moveTo(arrowStartX, arrowY);
                    simCtx.lineTo(arrowEndX, arrowY);
                    simCtx.stroke();

                    simCtx.beginPath();
                    simCtx.moveTo(arrowEndX, arrowY);
                    simCtx.lineTo(arrowEndX + 12, arrowY - 8);
                    simCtx.lineTo(arrowEndX + 12, arrowY + 8);
                    simCtx.closePath();
                    simCtx.fill();

                    simCtx.fillStyle = '#fff';
                    simCtx.font = 'bold 13px Arial';
                    simCtx.textAlign = 'center';
                    simCtx.fillText('â† MOVING AWAY', starX - arrowLength / 2, arrowY - 15);
                } else {
                    const arrowStartX = starX;
                    const arrowEndX = starX + arrowLength;

                    simCtx.beginPath();
                    simCtx.moveTo(arrowStartX, arrowY);
                    simCtx.lineTo(arrowEndX, arrowY);
                    simCtx.stroke();

                    simCtx.beginPath();
                    simCtx.moveTo(arrowEndX, arrowY);
                    simCtx.lineTo(arrowEndX - 12, arrowY - 8);
                    simCtx.lineTo(arrowEndX - 12, arrowY + 8);
                    simCtx.closePath();
                    simCtx.fill();

                    simCtx.fillStyle = '#fff';
                    simCtx.font = 'bold 13px Arial';
                    simCtx.textAlign = 'center';
                    simCtx.fillText('MOVING CLOSER â†’', starX + arrowLength / 2, arrowY - 15);
                }
            }

            const shiftIndicator = document.getElementById('shiftIndicator');
            if (beta > 0.05) {
                shiftIndicator.textContent = 'REDSHIFT';
                shiftIndicator.style.background = 'rgba(255, 107, 107, 0.3)';
                shiftIndicator.style.color = '#ff6b6b';
                shiftIndicator.style.borderLeft = '4px solid #ff6b6b';
            } else if (beta < -0.05) {
                shiftIndicator.textContent = 'BLUESHIFT';
                shiftIndicator.style.background = 'rgba(77, 171, 247, 0.3)';
                shiftIndicator.style.color = '#4dabf7';
                shiftIndicator.style.borderLeft = '4px solid #4dabf7';
            } else {
                shiftIndicator.textContent = '';
                shiftIndicator.style.background = 'transparent';
            }
        }

        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;

            graphCtx.fillStyle = '#000';
            graphCtx.fillRect(0, 0, w, h);

            graphCtx.strokeStyle = 'rgba(100, 181, 246, 0.2)';
            graphCtx.lineWidth = 1;

            for (let i = 0; i <= 10; i++) {
                const x = (w * 0.1) + (w * 0.8) * (i / 10);
                graphCtx.beginPath();
                graphCtx.moveTo(x, h * 0.1);
                graphCtx.lineTo(x, h * 0.9);
                graphCtx.stroke();

                const y = h * 0.1 + (h * 0.8) * (i / 10);
                graphCtx.beginPath();
                graphCtx.moveTo(w * 0.1, y);
                graphCtx.lineTo(w * 0.9, y);
                graphCtx.stroke();
            }

            graphCtx.strokeStyle = '#64b5f6';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(w * 0.1, h * 0.9);
            graphCtx.lineTo(w * 0.9, h * 0.9);
            graphCtx.moveTo(w * 0.1, h * 0.9);
            graphCtx.lineTo(w * 0.1, h * 0.1);
            graphCtx.stroke();

            graphCtx.fillStyle = '#90caf9';
            graphCtx.font = '12px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Position', w / 2, h - 10);
            graphCtx.save();
            graphCtx.translate(20, h / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('Amplitude', 0, 0);
            graphCtx.restore();

            const doppler = calculateDopplerShift();
            const centerY = h * 0.5;
            const amplitude = h * 0.25;
            const beta = velocityMeters / c;

            const compressionFactor = beta < 0 ?
                (1 - Math.abs(beta) * 0.7) :
                (1 + beta * 0.7);

            graphCtx.strokeStyle = '#64b5f6';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();

            const baseWaveCount = 5;
            for (let x = w * 0.1; x <= w * 0.9; x += 1) {
                const normalizedX = (x - w * 0.1) / (w * 0.8);
                const phase = (normalizedX * Math.PI * 2 * baseWaveCount) - time * animSpeed;
                const y = centerY + Math.sin(phase) * amplitude * 0.6;
                if (x === w * 0.1) {
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
            }
            graphCtx.stroke();

            const observedColor = wavelengthToRGB(doppler.wavelength);
            graphCtx.strokeStyle = observedColor;
            graphCtx.lineWidth = 3;
            graphCtx.beginPath();

            for (let x = w * 0.1; x <= w * 0.9; x += 1) {
                const normalizedX = (x - w * 0.1) / (w * 0.8);
                const adjustedX = normalizedX / compressionFactor;
                const phase = (adjustedX * Math.PI * 2 * baseWaveCount) - time * animSpeed;
                const y = centerY + Math.sin(phase) * amplitude * 0.8;
                if (x === w * 0.1) {
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
            }
            graphCtx.stroke();

            document.getElementById('observedColor').style.background = observedColor;
        }

        function formatVelocity(vel) {
            const absVel = Math.abs(vel);
            if (absVel >= 1e6) {
                return (vel / 1e6).toFixed(2) + ' Ã— 10â¶ m/s';
            } else if (absVel >= 1e3) {
                return (vel / 1e3).toFixed(2) + ' Ã— 10Â³ m/s';
            } else {
                return vel.toFixed(2) + ' m/s';
            }
        }

        function updateStatus() {
            const doppler = calculateDopplerShift();
            const shift = ((doppler.wavelength - restWavelength) / restWavelength * 100);
            const beta = velocityMeters / c;

            const effectType = document.getElementById('effectType');
            const effectText = beta > 0 ? 'Redshift' : beta < 0 ? 'Blueshift' : 'Neutral';
            effectType.textContent = effectText;
            effectType.className = 'status-value ' + (beta > 0 ? 'redshift' : beta < 0 ? 'blueshift' : '');

            document.getElementById('velocityDisplay').textContent = formatVelocity(velocityMeters);
            document.getElementById('observedWavelength').textContent = doppler.wavelength.toFixed(1) + ' nm';
            document.getElementById('observedFrequency').textContent = doppler.frequency.toFixed(1) + ' THz';
            document.getElementById('shift').textContent = (shift >= 0 ? '+' : '') + shift.toFixed(2) + '%';
        }

        function animate() {
            time += 0.016 * animSpeed;
            drawSimulation();
            drawGraph();
            updateStatus();
            requestAnimationFrame(animate);
        }

        document.getElementById('blueshiftVelocity').addEventListener('input', function (e) {
            let value = parseFloat(e.target.value) || 0;
            if (value < 0) value = 0;
            velocityMeters = -value;
            document.getElementById('redshiftVelocity').value = '';
        });

        document.getElementById('redshiftVelocity').addEventListener('input', function (e) {
            let value = parseFloat(e.target.value) || 0;
            if (value < 0) value = 0;
            velocityMeters = value;
            document.getElementById('blueshiftVelocity').value = '';
        });

        // Draw observer once
        drawObserver();

        animate();

    </script>
</body>

</html>