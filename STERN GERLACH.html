<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STERN GERLACH</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap');

        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #2a1f3a 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            flex-direction: row;
            gap: 30px;
            align-items: flex-start;
            justify-content: center;
            margin-top: 20px;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }

        .formula-box {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            text-align: center;
        }

        .formula-title {
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .formula {
            font-size: 36px;
            color: #ffffff;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            line-height: 1.8;
        }

        .formula sub {
            font-size: 24px;
        }

        .formula-description {
            color: #cccccc;
            font-size: 14px;
            margin-top: 15px;
            line-height: 1.6;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            animation: gradientShift 3s ease infinite, glow 2s ease-in-out infinite;
            margin: 20px 0 40px 0;
            letter-spacing: 8px;
            text-decoration: underline;
            text-decoration-style: double;
            text-decoration-color: #00ffff;
            text-decoration-thickness: 4px;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes glow {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.3);
            }
        }

        .canvas-wrapper {
            position: relative;
        }

        #canvas {
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.5);
            background: radial-gradient(circle at center, #0d1129 0%, #050812 100%);
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #00ffff;
            border-radius: 10px;
            background: linear-gradient(135deg, #1a237e 0%, #0d47a1 100%);
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

        button:hover {
            background: linear-gradient(135deg, #0d47a1 0%, #1a237e 100%);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .mode-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        .switch-label {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
        }

        .mode-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 2px;
            transition: all 0.3s;
            opacity: 0.4;
        }

        .mode-text.active {
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .mode-text.classical {
            color: #ffaa00;
        }

        .mode-text.quantum {
            color: #00ffff;
        }

        .switch-label input[type="checkbox"] {
            display: none;
        }

        .slider {
            position: relative;
            width: 60px;
            height: 30px;
            background: rgba(255, 170, 0, 0.3);
            border: 2px solid #ffaa00;
            border-radius: 15px;
            transition: all 0.3s;
        }

        .slider::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            left: 2px;
            top: 2px;
            background: #ffaa00;
            border-radius: 50%;
            transition: all 0.3s;
            box-shadow: 0 0 10px #ffaa00;
        }

        input[type="checkbox"]:checked+.slider {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }

        input[type="checkbox"]:checked+.slider::before {
            transform: translateX(30px);
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>

<body>
    <h1>STERN GERLACH</h1>
    <div class="main-container">
        <div class="canvas-wrapper">
            <canvas id="canvas" width="1000" height="600"></canvas>
            <button id="toggleBtn" onclick="toggleSimulation()">Start Simulation</button>
            <div class="mode-switch">
                <label class="switch-label">
                    <span class="mode-text classical active">CLASSICAL</span>
                    <input type="checkbox" id="modeToggle" onchange="changeMode()">
                    <span class="slider"></span>
                    <span class="mode-text quantum">QUANTUM</span>
                </label>
            </div>
        </div>
        <div class="side-panel">
            <div class="formula-box">
                <div class="formula-title">MAGNETIC FORCE</div>
                <div class="formula">F = μ<sub>z</sub> <span style="font-size: 28px;">dB/dz</span></div>
                <div class="formula-description">
                    Force on magnetic dipole<br>
                    in inhomogeneous field
                </div>
            </div>
            <div class="formula-box" style="width: 400px;">
                <div class="formula-title">DETECTION DISTRIBUTION</div>
                <canvas id="graphCanvas" width="400" height="250"></canvas>
                <div class="formula-description">
                    X-axis: Position on detector screen (deflection)<br>
                    Y-axis: Number of particles (intensity)
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        let particles = [];
        let isRunning = false;
        let animationId = null;
        let magnetPulse = 0;
        let isQuantumMode = false;

        const source = { x: 100, y: 300 };
        const magnetTop = { x: 400, y: 150, width: 150, height: 40 };
        const magnetBottom = { x: 400, y: 410, width: 150, height: 40, coneWidth: 80 };
        const screen = { x: 850, y: 50, width: 40, height: 500 };

        const spinUpDetections = [];
        const spinDownDetections = [];
        const detectionHistory = new Array(50).fill(0).map(() => ({ up: 0, down: 0 }));

        class Particle {
            constructor() {
                this.x = source.x;
                this.y = source.y;
                this.size = 5;

                if (isQuantumMode) {
                    this.spin = Math.random() > 0.5 ? 'up' : 'down';
                    const gaussianOffset = (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 0.15;
                    this.deflectionAngle = this.spin === 'up' ? (-0.6 + gaussianOffset) : (0.6 + gaussianOffset);
                    this.color = this.spin === 'up' ? '#00ff88' : '#ff0088';
                } else {
                    this.spin = 'continuous';
                    const angle = (Math.random() - 0.5) * 2;
                    this.deflectionAngle = angle * 0.6;

                    if (angle > 0.3) {
                        this.color = '#ff0088';
                    } else if (angle < -0.3) {
                        this.color = '#00ff88';
                    } else {
                        const mixFactor = (angle + 0.3) / 0.6;
                        const r = Math.floor(255 * mixFactor);
                        const g = Math.floor(255 * (1 - Math.abs(mixFactor - 0.5) * 2));
                        const b = 136;
                        this.color = `rgb(${r}, ${g}, ${b})`;
                    }
                }

                this.velocity = 1.5;
                this.inMagnet = false;
                this.deflected = false;
                this.trail = [];
            }

            update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 30) this.trail.shift();

                if (!this.deflected && this.x >= magnetTop.x && this.x <= magnetTop.x + magnetTop.width) {
                    this.inMagnet = true;
                    this.deflected = true;
                }

                if (this.inMagnet) {
                    this.x += this.velocity;
                    this.y += this.deflectionAngle;
                } else {
                    this.x += this.velocity;
                }

                if (this.x >= screen.x) {
                    const binIndex = Math.floor(((this.y - screen.y) / screen.height) * 50);
                    if (binIndex >= 0 && binIndex < 50) {
                        if (isQuantumMode) {
                            if (this.spin === 'up') {
                                detectionHistory[binIndex].up++;
                            } else {
                                detectionHistory[binIndex].down++;
                            }
                        } else {
                            detectionHistory[binIndex].up++;
                        }
                    }

                    if (isQuantumMode) {
                        if (this.spin === 'up') {
                            spinUpDetections.push({ x: this.x, y: this.y, alpha: 1 });
                        } else {
                            spinDownDetections.push({ x: this.x, y: this.y, alpha: 1 });
                        }
                    } else {
                        spinUpDetections.push({ x: this.x, y: this.y, alpha: 1, color: this.color });
                    }
                    return false;
                }
                return true;
            }

            draw() {
                ctx.strokeStyle = this.color + '44';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();

                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSource() {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff6600';
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(source.x - 40, source.y - 30, 60, 60);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(source.x - 35, source.y - 25, 50, 50);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Ag', source.x - 10, source.y + 5);

            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Silver Atoms', source.x - 10, source.y - 45);
        }

        function drawMagneticFieldLines() {
            const centerY = (magnetTop.y + magnetTop.height + magnetBottom.y) / 2;

            ctx.lineWidth = 2;

            for (let i = 0; i < 12; i++) {
                const startX = magnetTop.x + 10 + i * 11;
                const startY = magnetTop.y + magnetTop.height;

                ctx.beginPath();
                ctx.moveTo(startX, startY);

                const lateralSpread = (i - 5.5) * 18;
                const curvature = (i - 5.5) * 15;

                const endXOffset = lateralSpread * 0.8;
                const endX = magnetBottom.x + magnetBottom.width / 2 - magnetBottom.coneWidth / 2 + (i / 12) * magnetBottom.coneWidth;
                const endY = magnetBottom.y;

                const cp1x = startX + 15 + lateralSpread * 0.5;
                const cp1y = startY + 50 + Math.abs(curvature) * 1.5;
                const cp2x = endX - 15 + endXOffset * 0.5;
                const cp2y = endY - 50 + Math.abs(curvature) * 1.5;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);

                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, 'rgba(255, 30, 30, 0.7)');
                gradient.addColorStop(0.3, 'rgba(255, 80, 120, 0.5)');
                gradient.addColorStop(0.7, 'rgba(120, 80, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(30, 80, 255, 0.7)');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2.5 + Math.abs(5.5 - i) * 0.4;

                ctx.stroke();

                const t = 0.5;
                const arrowX = Math.pow(1 - t, 3) * startX + 3 * Math.pow(1 - t, 2) * t * cp1x + 3 * (1 - t) * Math.pow(t, 2) * cp2x + Math.pow(t, 3) * endX;
                const arrowY = Math.pow(1 - t, 3) * startY + 3 * Math.pow(1 - t, 2) * t * cp1y + 3 * (1 - t) * Math.pow(t, 2) * cp2y + Math.pow(t, 3) * endY;
                const angle = Math.atan2((endY - startY), (endX - startX)) + lateralSpread * 0.01;
                drawArrow(arrowX - 5, arrowY - 5, arrowX + Math.cos(angle) * 15, arrowY + Math.sin(angle) * 15, 'rgba(255, 255, 255, 0.5)');
            }

            const gradientStartX = magnetTop.x + magnetTop.width + 20;
            const gradientWidth = 100;

            for (let y = magnetTop.y + magnetTop.height; y < magnetBottom.y; y += 2) {
                const progress = (y - (magnetTop.y + magnetTop.height)) / (magnetBottom.y - magnetTop.y - magnetTop.height);

                const fieldStrength = 0.85 - progress * 0.6 + Math.sin(progress * Math.PI * 4) * 0.2;
                const alpha = fieldStrength * 0.5;
                const xOffset = Math.sin(progress * Math.PI * 3) * 25 + Math.cos(progress * Math.PI * 5) * 10;
                const widthVariation = 1 - Math.abs(0.5 - progress) * 0.7;

                const colorMix = progress * 255;
                ctx.fillStyle = `rgba(${Math.floor(255 - colorMix * 0.5)}, ${Math.floor(150 + colorMix * 0.3)}, ${Math.floor(200 + colorMix * 0.2)}, ${alpha})`;
                ctx.fillRect(gradientStartX + xOffset, y, gradientWidth * widthVariation, 2);
            }

            ctx.fillStyle = 'rgba(0, 255, 200, 0.8)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('∂B/∂z ≠ 0', gradientStartX + 50, centerY - 65);
            ctx.font = 'bold 11px Arial';
            ctx.fillText('(Non-uniform)', gradientStartX + 50, centerY - 48);
            ctx.fillText('Curved Field', gradientStartX + 50, centerY - 33);

            ctx.fillStyle = 'rgba(255, 80, 80, 0.7)';
            ctx.font = 'bold 11px Arial';
            ctx.fillText('Strong (3T)', gradientStartX + 50, magnetTop.y + magnetTop.height + 20);
            ctx.fillStyle = 'rgba(80, 120, 255, 0.7)';
            ctx.fillText('Strong (2T)', gradientStartX + 50, magnetBottom.y - 10);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.fillText('Gradient', gradientStartX + 50, centerY + 5);
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headlen = 6;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawMagnets() {
            magnetPulse += 0.05;
            const pulseIntensity = Math.sin(magnetPulse) * 0.3 + 0.7;

            drawMagneticFieldLines();

            ctx.shadowBlur = 20 * pulseIntensity;
            ctx.shadowColor = '#ff0000';

            const gradientTop = ctx.createLinearGradient(magnetTop.x, magnetTop.y, magnetTop.x, magnetTop.y + magnetTop.height);
            gradientTop.addColorStop(0, `rgba(255, ${Math.floor(50 * pulseIntensity)}, 0, 1)`);
            gradientTop.addColorStop(1, `rgba(204, 0, 0, ${pulseIntensity})`);
            ctx.fillStyle = gradientTop;
            ctx.fillRect(magnetTop.x, magnetTop.y, magnetTop.width, magnetTop.height);

            ctx.strokeStyle = `rgba(255, 102, 102, ${pulseIntensity})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(magnetTop.x, magnetTop.y, magnetTop.width, magnetTop.height);

            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('N', magnetTop.x + magnetTop.width / 2, magnetTop.y + 27);
            ctx.font = 'bold 12px Arial';
            ctx.fillText('3T', magnetTop.x + magnetTop.width / 2, magnetTop.y + 15);

            ctx.shadowBlur = 20 * pulseIntensity;
            ctx.shadowColor = '#0066ff';

            ctx.beginPath();
            ctx.moveTo(magnetBottom.x + magnetBottom.width / 2 - magnetBottom.coneWidth / 2, magnetBottom.y);
            ctx.lineTo(magnetBottom.x + magnetBottom.width / 2 + magnetBottom.coneWidth / 2, magnetBottom.y);
            ctx.lineTo(magnetBottom.x + magnetBottom.width / 2 + magnetBottom.width / 2, magnetBottom.y + magnetBottom.height);
            ctx.lineTo(magnetBottom.x + magnetBottom.width / 2 - magnetBottom.width / 2, magnetBottom.y + magnetBottom.height);
            ctx.closePath();

            const gradientBottom = ctx.createLinearGradient(
                magnetBottom.x + magnetBottom.width / 2,
                magnetBottom.y,
                magnetBottom.x + magnetBottom.width / 2,
                magnetBottom.y + magnetBottom.height
            );
            gradientBottom.addColorStop(0, `rgba(0, ${Math.floor(102 * pulseIntensity)}, 255, 1)`);
            gradientBottom.addColorStop(0.5, `rgba(0, 85, 220, ${pulseIntensity})`);
            gradientBottom.addColorStop(1, `rgba(0, 68, 204, ${pulseIntensity})`);
            ctx.fillStyle = gradientBottom;
            ctx.fill();

            ctx.strokeStyle = `rgba(102, 153, 255, ${pulseIntensity})`;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(magnetBottom.x + magnetBottom.width / 2 - magnetBottom.coneWidth / 2, magnetBottom.y);
            ctx.lineTo(magnetBottom.x + magnetBottom.width / 2, magnetBottom.y - 5);
            ctx.lineTo(magnetBottom.x + magnetBottom.width / 2 + magnetBottom.coneWidth / 2, magnetBottom.y);
            ctx.strokeStyle = `rgba(150, 180, 255, ${pulseIntensity * 0.7})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('S', magnetBottom.x + magnetBottom.width / 2, magnetBottom.y + 27);
            ctx.font = 'bold 12px Arial';
            ctx.fillText('2T', magnetBottom.x + magnetBottom.width / 2, magnetBottom.y + 15);

            for (let i = 0; i < 20; i++) {
                const t = (magnetPulse * 2 + i * 0.3) % (Math.PI * 2);
                const lateralOffset = (i - 10) * 4;
                const x = magnetTop.x + magnetTop.width / 2 + Math.sin(t * 2) * 40 + lateralOffset;
                const yProgress = t / (Math.PI * 2);
                const y = magnetTop.y + magnetTop.height + 50 + (magnetBottom.y - magnetTop.y - magnetTop.height - 100) * yProgress;
                const size = 2 + Math.sin(t * 3) * 1;
                const alpha = 0.3 + Math.sin(t * 2) * 0.2;

                ctx.globalAlpha = alpha;
                ctx.fillStyle = i % 2 === 0 ? '#00ffff' : '#ff00ff';
                ctx.shadowBlur = 8;
                ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawScreen() {
            const gradient = ctx.createLinearGradient(screen.x, screen.y, screen.x + screen.width, screen.y);
            gradient.addColorStop(0, '#444444');
            gradient.addColorStop(0.5, '#666666');
            gradient.addColorStop(1, '#444444');
            ctx.fillStyle = gradient;
            ctx.fillRect(screen.x, screen.y, screen.width, screen.height);

            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 2;
            ctx.strokeRect(screen.x, screen.y, screen.width, screen.height);

            spinUpDetections.forEach((det, index) => {
                ctx.shadowBlur = 10;
                const color = det.color || '#00ff88';
                ctx.shadowColor = color;
                ctx.fillStyle = color.includes('rgb') ? color.replace('rgb', 'rgba').replace(')', `, ${det.alpha})`) : `rgba(0, 255, 136, ${det.alpha})`;
                ctx.beginPath();
                ctx.arc(screen.x + 20, det.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                det.alpha *= 0.98;
                if (det.alpha < 0.01) spinUpDetections.splice(index, 1);
            });

            spinDownDetections.forEach((det, index) => {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0088';
                ctx.fillStyle = `rgba(255, 0, 136, ${det.alpha})`;
                ctx.beginPath();
                ctx.arc(screen.x + 20, det.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                det.alpha *= 0.98;
                if (det.alpha < 0.01) spinDownDetections.splice(index, 1);
            });

            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            if (isQuantumMode) {
                ctx.fillText('Spin ↑', screen.x + 50, screen.y + 60);
                ctx.font = '14px Arial';
                ctx.fillText('μz = +μB', screen.x + 50, screen.y + 80);
            } else {
                ctx.fillText('Up', screen.x + 50, screen.y + 60);
                ctx.font = '14px Arial';
                ctx.fillText('deflection', screen.x + 50, screen.y + 80);
            }

            ctx.fillStyle = '#ff0088';
            ctx.font = 'bold 16px Arial';
            if (isQuantumMode) {
                ctx.fillText('Spin ↓', screen.x + 50, screen.y + screen.height - 40);
                ctx.font = '14px Arial';
                ctx.fillText('μz = -μB', screen.x + 50, screen.y + screen.height - 20);
            } else {
                ctx.fillText('Down', screen.x + 50, screen.y + screen.height - 40);
                ctx.font = '14px Arial';
                ctx.fillText('deflection', screen.x + 50, screen.y + screen.height - 20);
            }
        }

        function drawGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);

            graphCtx.strokeStyle = '#00ffff';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(40, 10);
            graphCtx.lineTo(40, 210);
            graphCtx.lineTo(390, 210);
            graphCtx.stroke();

            graphCtx.fillStyle = '#00ffff';
            graphCtx.font = 'bold 12px Arial';
            graphCtx.save();
            graphCtx.translate(15, 110);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.textAlign = 'center';
            graphCtx.fillText('Intensity', 0, 0);
            graphCtx.restore();

            graphCtx.textAlign = 'center';
            graphCtx.fillText('Position', 215, 235);

            let maxCount = 1;
            detectionHistory.forEach(bin => {
                const total = bin.up + bin.down;
                if (total > maxCount) maxCount = total;
            });

            const barWidth = 6.5;

            if (isQuantumMode) {
                const upPeak = 12;
                const downPeak = 37;
                const sigma = 3.5;

                graphCtx.strokeStyle = '#00ff88';
                graphCtx.lineWidth = 3;
                graphCtx.shadowBlur = 8;
                graphCtx.shadowColor = '#00ff88';
                graphCtx.beginPath();

                for (let i = 0; i < 50; i++) {
                    const upIntensity = Math.exp(-Math.pow(i - upPeak, 2) / (2 * sigma * sigma));
                    const upCount = detectionHistory[i].up;
                    const displayHeight = upCount > 0 ? (upCount / maxCount) * 180 : upIntensity * 180 * 0.3;
                    const x = 40 + (i * 7) + barWidth / 2;
                    const y = 210 - displayHeight;

                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                }
                graphCtx.stroke();
                graphCtx.shadowBlur = 0;

                graphCtx.strokeStyle = '#ff0088';
                graphCtx.shadowBlur = 8;
                graphCtx.shadowColor = '#ff0088';
                graphCtx.beginPath();

                for (let i = 0; i < 50; i++) {
                    const downIntensity = Math.exp(-Math.pow(i - downPeak, 2) / (2 * sigma * sigma));
                    const downCount = detectionHistory[i].down;
                    const displayHeight = downCount > 0 ? (downCount / maxCount) * 180 : downIntensity * 180 * 0.3;
                    const x = 40 + (i * 7) + barWidth / 2;
                    const y = 210 - displayHeight;

                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                }
                graphCtx.stroke();
                graphCtx.shadowBlur = 0;

                detectionHistory.forEach((bin, i) => {
                    const x = 40 + (i * 7);

                    if (bin.up > 0) {
                        const upHeight = (bin.up / maxCount) * 180;
                        graphCtx.fillStyle = 'rgba(0, 255, 136, 0.6)';
                        graphCtx.fillRect(x, 210 - upHeight, barWidth, upHeight);
                    }

                    if (bin.down > 0) {
                        const downHeight = (bin.down / maxCount) * 180;
                        graphCtx.fillStyle = 'rgba(255, 0, 136, 0.6)';
                        graphCtx.fillRect(x, 210 - downHeight, barWidth, downHeight);
                    }
                });
            } else {
                const centerPeak = 25;
                const sigma = 8;

                graphCtx.strokeStyle = '#ffaa00';
                graphCtx.lineWidth = 3;
                graphCtx.shadowBlur = 8;
                graphCtx.shadowColor = '#ffaa00';
                graphCtx.beginPath();

                for (let i = 0; i < 50; i++) {
                    const intensity = Math.exp(-Math.pow(i - centerPeak, 2) / (2 * sigma * sigma));
                    const count = detectionHistory[i].up;
                    const displayHeight = count > 0 ? (count / maxCount) * 180 : intensity * 180 * 0.3;
                    const x = 40 + (i * 7) + barWidth / 2;
                    const y = 210 - displayHeight;

                    if (i === 0) {
                        graphCtx.moveTo(x, y);
                    } else {
                        graphCtx.lineTo(x, y);
                    }
                }
                graphCtx.stroke();
                graphCtx.shadowBlur = 0;

                detectionHistory.forEach((bin, i) => {
                    const x = 40 + (i * 7);
                    const height = (bin.up / maxCount) * 180;
                    if (height > 0) {
                        const gradientPos = Math.abs(i - 25) / 25;
                        const r = Math.floor(255 * gradientPos);
                        const g = Math.floor(200 * (1 - gradientPos));
                        graphCtx.fillStyle = `rgba(${r}, ${g}, 136, 0.6)`;
                        graphCtx.fillRect(x, 210 - height, barWidth, height);
                    }
                });
            }

            if (isQuantumMode) {
                graphCtx.fillStyle = '#00ff88';
                graphCtx.fillRect(250, 20, 15, 10);
                graphCtx.fillStyle = '#ffffff';
                graphCtx.font = '11px Arial';
                graphCtx.textAlign = 'left';
                graphCtx.fillText('Spin ↑', 270, 28);

                graphCtx.fillStyle = '#ff0088';
                graphCtx.fillRect(250, 35, 15, 10);
                graphCtx.fillStyle = '#ffffff';
                graphCtx.fillText('Spin ↓', 270, 43);

                graphCtx.fillStyle = '#aaaaaa';
                graphCtx.font = '10px Arial';
                graphCtx.fillText('Gaussian', 270, 56);
                graphCtx.fillText('Distribution', 270, 67);
            } else {
                graphCtx.fillStyle = '#ffaa00';
                graphCtx.fillRect(250, 20, 15, 10);
                graphCtx.fillStyle = '#ffffff';
                graphCtx.font = '11px Arial';
                graphCtx.textAlign = 'left';
                graphCtx.fillText('Continuous', 270, 28);
                graphCtx.fillText('Gaussian', 270, 43);
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawSource();
            drawMagnets();
            drawScreen();
            drawGraph();

            if (isRunning && Math.random() > 0.85) {
                particles.push(new Particle());
            }

            particles = particles.filter(particle => {
                particle.draw();
                return particle.update();
            });

            if (isRunning || particles.length > 0 || spinUpDetections.length > 0 || spinDownDetections.length > 0) {
                animationId = requestAnimationFrame(animate);
            } else {
                animationId = null;
            }
        }

        function toggleSimulation() {
            const btn = document.getElementById('toggleBtn');
            if (!isRunning) {
                isRunning = true;
                btn.textContent = 'Stop Simulation';
                if (!animationId) {
                    animate();
                }
            } else {
                isRunning = false;
                btn.textContent = 'Start Simulation';
            }
        }

        function changeMode() {
            isQuantumMode = document.getElementById('modeToggle').checked;

            const classicalText = document.querySelector('.mode-text.classical');
            const quantumText = document.querySelector('.mode-text.quantum');

            if (isQuantumMode) {
                classicalText.classList.remove('active');
                quantumText.classList.add('active');
            } else {
                classicalText.classList.add('active');
                quantumText.classList.remove('active');
            }

            particles = [];
            spinUpDetections.length = 0;
            spinDownDetections.length = 0;
            detectionHistory.forEach(bin => {
                bin.up = 0;
                bin.down = 0;
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSource();
            drawMagnets();
            drawScreen();
            drawGraph();
        }

        drawSource();
        drawMagnets();
        drawScreen();
        drawGraph();
    </script>
</body>

</html>