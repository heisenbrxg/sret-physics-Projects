<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Kronig–Penney Interactive (delta) — Band Diagram</title>
<style>
  body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#fbfcff; color:#111; margin:0; padding:18px; }
  h1 { margin:4px 0 8px; font-size:20px; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
  .control { background:#fff; border-radius:8px; padding:10px; box-shadow:0 2px 6px rgba(20,30,60,0.06); }
  label { display:block; font-size:13px; margin-bottom:6px; color:#333; }
  input[type=range] { width:220px; }
  input[type=number] { width:80px; padding:6px; border-radius:6px; border:1px solid #ddd; }
  button { padding:8px 12px; border-radius:8px; border:0; background:#2563eb; color:#fff; cursor:pointer; }
  button.secondary { background:#475569; margin-left:8px; }
  canvas { background:white; border-radius:8px; box-shadow:0 6px 14px rgba(20,30,60,0.06); }
  .small { font-size:12px; color:#4b5563; }
  .flex-col { display:flex; flex-direction:column; }
  .spacer { height:12px; }
</style>
</head>
<body>

<h1>Kronig–Penney (delta) — Interactive Band Diagram</h1>
<div class="row">
  <div class="control flex-col">
    <label>Barrier strength P: <span id="Pval">8.0</span></label>
    <input type="range" id="P" min="0.5" max="50" step="0.1" value="8">
  </div>

  <div class="control flex-col">
    <label>Lattice spacing a: <span id="aval">1.00</span></label>
    <input type="range" id="a" min="0.3" max="3" step="0.01" value="1.0">
  </div>

  <div class="control flex-col">
    <label>Emax: <span id="Emaxval">60.0</span></label>
    <input type="range" id="Emax" min="10" max="200" step="1" value="60">
  </div>

  <div class="control flex-col">
    <label>Resolution (nE): <span id="nEval">4000</span></label>
    <input type="range" id="nE" min="500" max="20000" step="100" value="4000">
  </div>

  <div class="control" style="display:flex; align-items:center; gap:8px;">
    <button id="recalc">Recalculate</button>
    <button id="download" class="secondary">Download CSV</button>
  </div>
</div>

<div class="spacer"></div>

<!-- Plot canvases -->
<canvas id="bandCanvas" width="900" height="480"></canvas>
<div style="height:14px"></div>
<canvas id="potCanvas" width="900" height="140"></canvas>

<div class="spacer"></div>
<div class="small">Notes: This uses the delta-limit Kronig–Penney condition. Energies with |RHS| ≤ 1 are allowed. k = acos(rhs)/a gives principal branch (0..π/a); both ±k are shown for full symmetric band. Increase resolution (nE) for smoother bands.</div>

<script>
/* --- utilities --- */
const Pelem = document.getElementById('P');
const Aelem = document.getElementById('a');
const EmaxElem = document.getElementById('Emax');
const nEelem = document.getElementById('nE');
const Pval = document.getElementById('Pval');
const aval = document.getElementById('aval');
const Emaxval = document.getElementById('Emaxval');
const nEval = document.getElementById('nEval');
const recalcBtn = document.getElementById('recalc');
const downloadBtn = document.getElementById('download');

Pval.textContent = parseFloat(Pelem.value).toFixed(2);
aval.textContent = parseFloat(Aelem.value).toFixed(2);
Emaxval.textContent = parseFloat(EmaxElem.value).toFixed(1);
nEval.textContent = parseInt(nEelem.value);

Pelem.oninput = () => { Pval.textContent = parseFloat(Pelem.value).toFixed(2); }
Aelem.oninput = () => { aval.textContent = parseFloat(Aelem.value).toFixed(2); }
EmaxElem.oninput = () => { Emaxval.textContent = parseFloat(EmaxElem.value).toFixed(1); }
nEelem.oninput = () => { nEval.textContent = parseInt(nEelem.value); }

/* canvases */
const bandCanvas = document.getElementById('bandCanvas');
const bctx = bandCanvas.getContext('2d');
const potCanvas = document.getElementById('potCanvas');
const pctx = potCanvas.getContext('2d');

/* main compute & draw */
function computeAndDraw() {
  const P = parseFloat(Pelem.value);
  const a = parseFloat(Aelem.value);
  const Emax = parseFloat(EmaxElem.value);
  const nE = parseInt(nEelem.value);

  // compute E array
  const E = new Float64Array(nE);
  const dE = Emax / (nE - 1);
  for (let i=0;i<nE;i++) E[i] = i * dE + 1e-12;

  // compute rhs array: using kappa = sqrt(2*E) (consistent with user's python)
  const rhs = new Float64Array(nE);
  for (let i=0;i<nE;i++) {
    const Ei = E[i];
    const kappa = Math.sqrt(2 * Ei);
    if (kappa < 1e-10) {
      // series limit: sin(kappa*a)/(kappa) -> a, cos(kappa*a)->1
      rhs[i] = Math.cos(kappa * a) + P * a;
    } else {
      rhs[i] = Math.cos(kappa * a) + (P / kappa) * Math.sin(kappa * a);
    }
  }

  // allowed mask |rhs| <= 1
  const allowedIndices = [];
  for (let i=0;i<nE;i++) {
    if (Math.abs(rhs[i]) <= 1.0) allowedIndices.push(i);
  }

  // compute kvals from rhs and build data arrays including ±k
  const ks = [];
  const Es = [];
  for (let idx of allowedIndices) {
    const r = rhs[idx];
    // clamp numerical noise
    const rc = Math.max(-1, Math.min(1, r));
    const kval = Math.acos(rc) / a; // principal branch 0..pi/a
    ks.push(kval); Es.push(E[idx]);
    ks.push(-kval); Es.push(E[idx]);
  }

  // draw band diagram scatter
  drawBandPlot(bctx, ks, Es, a, Emax);

  // draw potential cartoon
  drawPotential(pctx, a, P);
  
  // return arrays for download if needed
  return {k: ks, E: Es};
}

/* plotting utilities */
function drawAxes(ctx, x0, y0, w, h, xLabel, yLabel) {
  ctx.clearRect(x0-2, y0-2, w+4, h+4);
  ctx.beginPath();
  ctx.strokeStyle = '#2b2b2b';
  ctx.lineWidth = 1;
  // y axis
  ctx.moveTo(x0, y0);
  ctx.lineTo(x0, y0 + h);
  // x axis
  ctx.moveTo(x0, y0 + h);
  ctx.lineTo(x0 + w, y0 + h);
  ctx.stroke();
  ctx.fillStyle='#222'; ctx.font='13px Inter, Arial';
  ctx.fillText(xLabel, x0 + w/2 - 30, y0 + h + 30);
  ctx.save();
  ctx.translate(x0 - 40, y0 + h/2 + 30);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();
}

function drawBandPlot(ctx, kArray, EArray, a, Emax) {
  // canvas inner dims
  const margin = 64;
  const w = ctx.canvas.width - margin*2;
  const h = ctx.canvas.height - margin*2;
  const x0 = margin, y0 = margin;

  // clear and axes
  ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
  drawAxes(ctx, x0, y0, w, h, 'k (1/a)', 'Energy E');

  // scales
  const kMin = -Math.PI / a, kMax = Math.PI / a;
  const EMin = 0, EMax = Emax;

  // draw vertical lines at ±pi/a
  ctx.strokeStyle = '#cbd5e1';
  ctx.lineWidth = 1;
  const xPiNeg = x0 + ((kMin - kMin)/(kMax - kMin)) * w;
  const xPiPos = x0 + ((Math.PI/a - kMin)/(kMax - kMin)) * w;
  ctx.beginPath();
  ctx.moveTo(xPiNeg, y0);
  ctx.lineTo(xPiNeg, y0 + h);
  ctx.moveTo(xPiPos, y0);
  ctx.lineTo(xPiPos, y0 + h);
  ctx.stroke();

  // scatter points
  ctx.fillStyle = '#dc2626'; // red-ish
  const r = 1.4; // marker radius
  for (let i=0;i<kArray.length;i++) {
    const k = kArray[i], E = EArray[i];
    if (!isFinite(k) || !isFinite(E)) continue;
    // map to pixel
    const x = x0 + ((k - kMin) / (kMax - kMin)) * w;
    const y = y0 + h - ((E - EMin) / (EMax - EMin)) * h;
    // skip if outside
    if (x < x0-5 || x > x0+w+5 || y < y0-5 || y > y0+h+5) continue;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();
  }

  // title and parameter text
  ctx.fillStyle = '#0f172a';
  ctx.font = '14px Inter, Arial';
  ctx.fillText(`a = ${a.toFixed(3)}   (lattice spacing)`, x0 + 8, y0 - 30);
  ctx.fillText(`Display E ∈ [0, ${EMax}]`, x0 + 240, y0 - 30);
  ctx.fillText(`Brillouin zone: [${( -Math.PI/a ).toFixed(3)}, ${(Math.PI/a).toFixed(3)}]`, x0 + 460, y0 - 30);
}

/* draw potential cartoon with Gaussians */
function drawPotential(ctx, a, P) {
  const W = ctx.canvas.width, H = ctx.canvas.height;
  ctx.clearRect(0,0,W,H);
  // draw baseline
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,W,H);
  // coordinate x from -3a..3a
  const npt = 1200;
  const xmin = -3*a, xmax = 3*a;
  const dx = (xmax - xmin) / (npt - 1);
  const xs = new Float64Array(npt);
  const Vs = new Float64Array(npt);
  const sigma = 0.03 * a; // narrow gaussians
  const norm = 1.0 / (Math.sqrt(2*Math.PI) * sigma);
  for (let i=0;i<npt;i++) {
    const x = xmin + i * dx;
    xs[i] = x;
    let val = 0;
    for (let n=-3;n<=3;n++){
      const xc = x - n*a;
      const g = Math.exp(-0.5 * (xc*xc)/(sigma*sigma)) * norm;
      val += P * g;
    }
    Vs[i] = val;
  }
  // normalize to canvas height
  const vmax = Math.max(...Vs);
  // draw curve
  ctx.beginPath();
  ctx.strokeStyle = '#0b5fff';
  ctx.lineWidth = 2;
  for (let i=0;i<npt;i++) {
    const xpix = (i / (npt-1)) * W;
    const ypix = H - 10 - (Vs[i] / vmax) * (H - 30);
    if (i==0) ctx.moveTo(xpix, ypix);
    else ctx.lineTo(xpix, ypix);
  }
  ctx.stroke();
  // labels
  ctx.fillStyle = '#0f172a'; ctx.font='13px Inter, Arial';
  ctx.fillText('Periodic delta-like spikes (visual)', 12, 18);
}

/* initial draw and wiring */
let lastData = null;
function runOnce() {
  lastData = computeAndDraw();
}
runOnce();

recalcBtn.onclick = () => { lastData = computeAndDraw(); };

downloadBtn.onclick = () => {
  if (!lastData) { alert('No data to download yet — recalculate first.'); return; }
  const ks = lastData.k;
  const Es = lastData.E;
  let csv = 'k,E\n';
  for (let i=0;i<ks.length;i++) {
    csv += `${ks[i]},${Es[i]}\n`;
  }
  const blob = new Blob([csv], {type: 'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'kp_band_data.csv';
  a.click();
  URL.revokeObjectURL(url);
};

</script>
</body>
</html>